---
# Page title
title: Django Forms

# Title for the menu link if you wish to use a shorter link title, otherwise remove this option.
linktitle: Forms

# Date page published
date: 2021-06-26T11:49:32Z

# Academic page type (do not modify).
type: book

# Position of this page in the menu. Remove this option to sort alphabetically.
weight: 10

draft: false


---

النموذج هو مكون HTML (أو علامة) يستخدم لإرسال إدخال المستخدم إلى خادم الويب أو خادم التطبيق. هناك نوعان رئيسيان متطابقان في ما يفعلونه ، ولكن مختلفين في كيفية القيام بذلك:

- تتضمن نماذج POST بيانات في نص طلب HTTP
- تتضمن نماذج GET بيانات في عنوان URL


لإرسال البيانات، يجب أن تتضمن النماذج دائما زر إرسال يقوم المستخدم بالنقر فوقه لتنفيذ إجراء الإرسال:

  ```html
  <form action="" method="POST">
    <!-- data input components here -->
    <input type=submit>
  </form>
  ```

## Django Forms
Django يوفر مكون النموذج الذي يدير إنشاء والتعامل مع نماذج HTML حتى لا يكون لدينا لإنشاء نماذج HTML يدويا. استخدام نماذج جانغو واتباع قواعد جانغو لاستخدامها عبر إنشاء نماذج HTML يدويا له الفوائد التالية:

- سيتم إنشاء النماذج تلقائيا لتطبيقنا لكل من إنشاء البيانات وتحديث الإجراءات لتعكس نماذج البيانات لدينا. كما أن تحديث نماذج البيانات من شأنه أيضا تحديث نماذج HTML الخاصة بنا تلقائيا نتيجة لذلك.
- ستقوم نماذج Django تلقائيا بمعالجة التحقق من صحة الإدخال للسماح للمستخدمين بإدخال بيانات صالحة فقط وإظهار الأخطاء المناسبة إذا لم يحدث ذلك دون أي جهد إضافي من المطور.
- كما ستتعامل نماذج Django تلقائيا مع أمان إدخال البيانات بدلا من تركه للمطور ، وهو التحدي الأكبر في تطبيقات الويب للعمل مع البيانات المقدمة من المستخدم. سيؤدي ذلك إلى تحسين أمان تطبيق Django على الويب لضمان حمايته من الهجمات الشائعة (على سبيل المثال ، حقن SQL و XSS و CSRF) وسيشمل أيضا أي تحسينات أمنية إضافية يقدمها مجتمع Django دون جهد إضافي من المطور.

## Using Django Forms

1. تعريف النماذج في forms.py
   نحن نشير إلى النموذج إلى النموذج الذي هو دعم لتوفير البيانات لأي قواعد إضافية حول البيانات. سيتم إنشاء الحقول تلقائيا من قبل جانغو استنادا إلى تعريف النموذج.
2. استيراد وإنشاء مثيل للنموذج الذي نود استخدامه في طريقة العرض المناسبة.
3. استخدم العرض لتضمين النموذج في القالب الذي يجب أن يتضمن:
   1. The HTML form tag
   2. The {% csrf_token %} inside the form
   3. The submit button


#### Defining Form Example

بعد إنشاء blog/forms.py، هكذا يبدو النموذج المستخدم لإرسال مشاركة المدونة من قبل المستخدم:
```python
from django import forms

from .models import Post

class PostForm(forms.ModelForm): #1
  class Meta: #2
    model = Post #3
    fields = ["title", "body"] #4
```

**Code Explanation:**
- **line #1:**  لاحظ كيف يرث PostForm من النماذج. ModelForm وسوف تحصل على جميع الميزات والفوائد التي تقدم جانغو في نموذج.
- **Line #2:** هذه هي الطريقة التي يتم بها توفير معلومات التكوين حول فئة كما يمكن رؤيتها في السطر #3 & #4
- **Line $3**:نحن نحدد نموذج جانغو الذي يستند هذا النموذج. سيتم الاستدلال على جميع الحقول والمعلومات من نموذج البريد الذي حددناه في models.py
- **Line #4**: له هو nn مثال معلومات تكوين إضافية خاصة للنموذج. نود أن يسمح النموذج للمستخدم فقط بإدخال العنوان والجسم ، ولا شيء آخر.


#### Using Forms in Views to Create Model Objects

هنا أنشأنا طريقة عرض خصيصا لإنشاء منشور وسنستخدم PostForm للسماح للمستخدمين بإنشاء المشاركات:

```python
from django.shortcuts import render, redirect #1

from .forms import PostForm #2

def create_post(request):
  form = PostForm(request.POST or None) #3

  data = {}
  data["form"] = form #4

  if form.is_valid(): #5
    post = form.save() #6
    return redirect("show-post", s=post.slug) #7

  return render(request, 'create_post.html', data) #8
```

**Code Explanatino:**
- **Line #1:** بعد إنشاء مشاركة بنجاح ، نريد إعادة توجيه المستخدم إلى طريقة عرض مختلفة ، مثل قائمة المشاركة ، لذلك نستورد وظيفة django المعاد توجيهها التي سنستخدمها في هذا العرض.
- **Line #2:** يجب استيراد فئة PostForm لاستخدامها هنا
- **Line #3:** هذا هو السطر الأكثر أهمية في التعليمات البرمجية الخاصة بنا حيث نقوم بإنشاء مثيل ل PostForm الذي سنستخدمه. تذكر، في OOP لا يمكننا استخدام فئة ما لم نخلق مثيلا لها. هنا نحن خلق مثيل للنموذج.
  - سيتم إرسال البيانات المقدمة من المستخدم دائما إلى وظيفة العرض من خلال وسيطة الطلب ، وهذا هو السبب في أننا يجب أن تشمل دائما هذه الحجة في وظيفة العرض حتى Django يمكن delver بيانات المستخدم في طلب HTTP. لذا الطلب. يعني جزء النشر أو بلا بشكل أساسي أننا نريد إنشاء PostForm باستخدام البيانات الواردة من المستخدم حتى يتمكن النموذج من التحقق من صحته ، أو إذا لم تكن هناك بيانات ، فقم بإنشاء PostForm فارغ لعرضه على المستخدم (وهذا هو جزء None ، مما يعني نموذج فارغ)
- **Line #4:** هنا نحن بما في ذلك النموذج الذي أنشأناه في السياق حتى نتمكن من إرساله إلى القالب ، وإلا فلن يتم عرضه.
- **Line #5:** هنا نطلب النموذج للتحقق من صحة إدخال المستخدم. إذا كان النموذج فارغا أو يحتوي على أية بيانات مفقودة أو غير صالحة، فإنه سيعود false وهكذا سوف الانتقال إلى سطر #8 لعرض النموذج مع أي أخطاء يحتاج المستخدم إلى رؤية. وإلا، ستكون النتيجة True وسيتم تنفيذ التعليمات البرمجية داخل إذا عبارة لإنشاء كائن نشر.
- **Line #6:** يجعل النموذج من الملائم إنشاء كائن نشر وتخزينه في قاعدة البيانات باستخدام البيانات المرسلة من قبل المستخدم. هنا نطلب من النموذج لإنشاء بوست باستخدام 'save()' الأسلوب ، والتي سيتم تخزينها في قاعدة البيانات. ومع ذلك ، فإننا نريد أيضا لتخزين آخر المحفوظة في متغير حتى نتمكن من استخدامه في وقت لاحق في إعادة توجيه حتى نتمكن من إجبار المتصفح لإظهار آخر أنشئت حديثا.
- **Line #7:** هنا نحن نستخدم إعادة توجيه، لاحظ أننا نعطيه اسم رابط أننا سوف تعيين كما سنرى في وقت لاحق بدلا من المسار. يمكن أن تطول المسارات ويصعب تذكرها ، حتى نتمكن من منحهم أسماء في urls.py ونطلب من جانغو استخدامها عند الحاجة. إذا كنت تتذكر، لعرض مشاركة معينة
 يجب أن نحدد معرفه، مثل الرصاصة. نحن نقول وظيفة تقديم أننا نريد orce المتصفح للمستخدم لإظهار عرض عرض آخر وعرض على وجه التحديد وظيفة أننا أنشأنا للتو عن طريق speficying سبيكة من آخر أنشئت حديثا.
- **Line #8:** هذه هي وظيفة التقديم العادية. فإنه سيتم عرض tempalte الذي يحتوي على النموذج بما في ذلك أي رسائل خطأ. **هذه هي وظيفة التقديم العادية. فإنه سيتم عرض tempalte الذي يحتوي على النموذج بما في ذلك أي رسائل خطأ.** وإلا يمكننا تقديم القالب الذي يحتوي على النموذج الفارغ.


#### A Note About URL names:

لاستخدام اسم مسار url مع إعادة توجيه، يجب أن نعطي المسارات في urls.py اسم:

```pythonthis
  path('post/<slug:s>/',views.show_post, name="show-post"),
```

لاحظ `name="show-post"` جزء في المسار، هنا أعطينا المسار اسم `show-post`. يجب أن يكون هذا الاسم فريدا في تطبيقنا ولا يمكن أن يحصل أي مسار آخر على نفس الاسم. يجعل من conveneinet لتحديد في إعادة توجيه المسار الذي نريد أن ترسل العميل إلى دون الحاجة إلى كتابة المسار بأكمله.

لاحظ أيضا `<slug:s>` جزء في المسار ، وهذا يعني أن الماضي يجب تحديد معرف (أو سبيكة في حالتنا) من آخر نريد أن نظهر. هذا هو السبب في إعادة توجيه الدعوة في وقت سابق كان علينا أن تشمل `s=post.slug` حتى نتمكن من تحديد سبيكة من وظيفة أنشئت حديثا في المسار ، وبالتالي إعادة توجيه متصفح المستخدم لإظهار وظيفة جديدة.

##### ماذا لو أردنا إعادة التوجيه إلى قائمة المشاركة بدلا من ذلك?

أولا ، نحن بحاجة إلى إعطاء المسار لإظهار قائمة المشاركة اسما:
```python
  path('posts/',views.list_posts, name="list-posts"),
```

ثم إعادة توجيه إلى هذا المسار باستخدام اسم انها مع عدم الحاجة إلى وسائط إضافية:
```python
  return redirect("list-posts")
```

وهذا كل شيء!

#### الخطوات النهائية لاستكمال create_post view

دعونا سلك عرض create_post:
```python
  path('create/post/',views.create_post)
```

وإنشاء القالب المستخدم من قبل طريقة العرض create_post التي تتضمن علامة نموذج HTML:
```html
<form action="." method="POST">
  {% csrf_token %}
  {{ form.as_p }}
<input type="submit" value="Submit">
</form>
```

وقد تم الآن عرض create_post واكتماله. ولكن تذكر، يجب أن تكون هناك علامة csrf_token لDjango لإدارة الأمن وجانغو سوف يشكو إذا نسيت أن تدرج ذلك. يمكنك أيضا استبدال `{{ form.as_p }}` مع `{{ form.as_table }}` إذا كنت تريد تغيير الطريقة التي يبدو النموذج.

#### Auto-Creating the Value of The Slug Field

هناك مشكلة واحدة مع وجهة نظرنا create_post، فإن حقل سبيكة تكون فارغة. يمكننا السماح للمستخدم بتحديد قيمة سبيكة ، ولكن من الأفضل لصناعة السيارات في خلق سبيكة من عنوان العنوان المقدمة من قبل المستخدم. جانغو يجعل هذا سهلا من خلال توفير وظيفة `slugify` الذي يأخذ سلسلة ويحولها إلى سبيكة صالحة. نريد أن نأخذ سلسلة العنوان، ونحولها إلى سبيكة، ونخزنها في حقل الرخويات.

للقيام بذلك، دعونا تحديث رمز create_post لدينا لاستخدام slugify. سيبقى كل شيء باستثناء بعض التعديلات:

```python
from django.utils.text import slugify #1

from .forms import PostForm

def create_post(request):
  form = PostForm(request.POST or None)

  data = {}
  data["form"] = form

  if form.is_valid():
    post = form.save(commit=False) #2
    post.slug = slugify(post.title) #3
    post.save() #4
    return redirect("show-post", s=post.slug)

  return render(request, 'create_post.html', data)
```

**Code explanation:**
- **Line #1:** نحن بحاجة لاستيراد وظيفة slugify التي نحتاج إلى استخدامها لتحويل العنوان إلى سبيكة
- **Line #2:** نستخدم `commit=False` الخيار بحيث يتم إنشاء بوست ولكن ليس تخزينها في قاعدة البيانات، ونحن تخزينه بعد أن نخلق سبيكة.
- **Line #3:** هنا نحن خلق سبيكة من العنوان ، وتذكر آخر يتم إنشاؤه ككائن ، ولكن ليس المخزنة في قاعدة البيانات.
- **Line #4:** هذا هو المكان الذي نقوم بتخزين آخر في قاعدة البيانات بعد أن أنشأنا سبيكة.
  

وستكون النتيجة كما يلي:

{{< figure src="courses/350/django-forms-result.png" width="35%" height="35%" caption="create post view with the form" >}}

---

{{< figure src="courses/350/django-forms-result2.png" width="35%" height="35%" caption="Input validation in forms" >}}

---

### Using Forms in Existing Views

ليس من الضروري إنشاء طريقة عرض خصيصا لاستخدام النماذج ، يمكننا تضمين النماذج في النماذج الموجودة. على سبيل المثال، يمكننا إضافة نموذج لإضافة تعليقات داخل طريقة عرض المشاركة.

شكل التعليق سيبدو كما يلي:
```python
from .models import Comment

class CommentForm(forms.ModelForm):
  class Meta:
    model = Comment
    fields = ["comment", "author", "email", "post"]
    widgets = { #1
      'post': forms.HiddenInput(), #2
    }
```

**Code explanation:**
- **Line #1:** نحن نستخدم خيار الحاجيات لتغيير كيفية عرض حقل في المتصفح، إزالته ومعرفة ما سيحدث.
- **Line #2:** هنا نحن تغيير حقل آخر ليكون حقل مخفي حيث يتم تضمين معرف آخر التعليق ينتمي إلى في النموذج ولكن لا تظهر للمستخدم. حقل الوظيفة هو كيفية ربط التعليق بوظيفة في قاعدة البيانات ويجب تضمينه في النموذج ، وإلا لن يعرف جانغو أي مشاركة لربط التعليق بها.

نقوم بتحديث show_post لتبدو كما يلي:
```python
def show_post(request, s):
  obj = Post.objects.get(slug=s)
  comments = obj.comment_set.all()
  data = {}
  data["post"] = obj
  data["comment_list"] = comments
  
  form = CommentForm(request.POST or None, initial={"post":obj.pk} ) #1
  data["comment_form"] = form #2
  if form.is_valid(): #3
    form.save() #4
    return redirect("show-post", s=obj.slug) #5
  
  return render(request, "post_detail.html", context=data)

```

**Code Explanation:**
- **Line #1:** هذه هي الإضافة الأولى إلى التعليمات البرمجية ، كل شيء آخر يبقى على حاله. هنا أنشأنا مثيل نموذج جديد تماما مثل create_post عرض في وقت سابق. ومع ذلك، لاحظ `initial={"post":obj.pk}` حجة، وهنا نحن نقول النموذج الذي نريد لتحديد وظيفة نريد لربط المستخدم إلى عندما يتم عرض النموذج بحيث المستخدم لن تحتاج إلى تحديده.

- **Lines 2 to 5:** لم يتغير شيء هنا من وجهة نظر show_post، كل شيء هو نفسه.

### Additional Notes on Widgets

- الحاجيات هي مكونات واجهة المستخدم المستخدمة لعرضها على المتصفح (e.g. buttons, textfields, text areas ..etc.)
- سوف جانغو تلقائيا تحديد القطعة المناسبة لكل حقل نموذج
- يمكننا استخدام الحاجيات الحقل عند تحديد النموذج لاختيار القطعة يدويا
- يمكن العثور على قائمة الحاجيات المتاحة في [Django Form Field Widgets documentation](https://docs.djangoproject.com/en/3.2/ref/forms/widgets/)

### Update Views

فهي متطابقة في كل شيء إلى وجهات النظر خلق. حتى أنهم يستخدمون نفس الشكل. الاستثناء الوحيد هو أننا بحاجة إلى تحديد الكائن الذي نريد تحديثه في المسار ، ويجب علينا تحميل الكائن وتمريره إلى النموذج بحيث يمكن للنموذج عرض البيانات الموجودة للمستخدم لتحريرها. لذلك نحن wuse `instance` حجة، وهذا كل شيء.

هنا مثال على `edit_post` طريقة العرض التي هي متطابقة تقريبا إلى `create_post` عرض باستثناء ثلاثة أسطر:


```python
def edit_post(request, s):
  p = get_object_or_404(Post, slug=s) #1
  f = PostForm(request.POST or None, instance=p) #2

  data = {}
  data["form"] = f
  data["post"] = p

  if f.is_valid():
    post = f.save(commit=False)
    post.slug = slugify(post.title)
    post.save()
    return redirect("show-post", s=post.slug)

  return render(request, 'edit_post.html', data) #3
```

**Code Explanation:**

- **Line #1:** نحن تحميل آخر نريد لتحرير من قاعدة البيانات.
- **Line #2:** لاحظ أننا نستخدم `instance=p` لإعطاء النموذج البيانات من قاعدة البيانات. سيتضمن النموذج البيانات من قاعدة البيانات في النموذج عند عرضها للمستخدم حتى يتمكنوا من تحريرها ويظل كل شيء آخر كما هو.
- **Line #3:** نحن نستخدم قالبا مختلفا لتغيير العناوين، ولكن النموذج هو نفسه تماما.


عند عرض النموذج للاستخدام، يمكنك مشاهدة أن البيانات الموجودة سيتم تضمينها في النموذج:

{{< figure src="courses/350/django-forms-edit.png" width="35%" height="35%" >}}


### The Deletion View

لا يوجد نموذج أو قالب Django مطلوب لحذف كائن. مجرد مسار يحدد الكائن المراد حذفه وإعادة توجيهه إلى طريقة عرض مختلفة عند النجاح. فيما يلي كيفية عرض الحذف سيبدو:

```python
def delete_post(request, s):
  p = get_object_or_404(Post, slug=s)
  p.delete()
  return redirect('list-posts')
```

يجب أن يحدد المسار الكائن الذي نريد حذفه ، لذلك في حالة المشاركات ، نقوم بتضمين سبيكة:

```python
path('delete/post/<slug:s>/',views.delete_post),
```

هذا هو!

بينما تقوم طريقة عرض الحذف هذه بالمهمة، لا ينصح بحذف الكائنات بدون شاشة تأكيد لمنع الحذف العرضي للبيانات. لذلك، نقوم بإنشاء قالب يتضمن نموذج HTML GET ليكون بمثابة خطوة التأكيد، دون استخدام نماذج Django.

هكذا سيبدو نموذج التأكيد، دعونا نسميه `confirm.html`:

```html
<h2>{{ message }}</h2>
<form action="." method="GET">
  <input type="submit" name="confirm" value="Confirm">  
  <input type="submit" name="cancel" value="Cancel">
</form>
```

**Important notes about confirm.html:**

- لاحظ أننا نستخدم نموذج GET بدون نماذج Django
- نضيف زرين إدخال مع سمة اسم
  - يتم استخدام سمة الاسم في شروطنا في طريقة العرض
  - سمة القيمة هي التسمية المعروضة على الأزرار
- ونحن تشمل أيضا `{{ message }}` المتغير الذي يسمح لنا لتخصيص رسالة تأكيد عرض للمستخدم.

لذلك دعونا تحديث طريقة عرض الحذف للاستفادة من شاشة التأكيد:

```python
def delete_post(request, s):
  p = get_object_or_404(Post, slug=s) #1
  m = f" Delete post {p.title}?" #2 
  data = { #3
    "message": m,
  }
  if "confirm" in request.GET: #4
    p.delete()
    return redirect('list-posts')
  elif "cancel" in request.GET: #5
    return redirect('list-posts')
  
  return render(request, "confirm.html", context=data) #6
```

**Code explanation:**
- **Line #1:** نقوم بتحميل الكائن المراد حذفه من قاعدة البيانات
- **Line #2:** نحن نبني رسالة التأكيد ليتم عرضها للمستخدم، والتي يمكن أن تشمل عنوان آخر.
- **Line #3:** نحن نبني السياق وندرج الرسالة فيه.
- **Line #4:** إذا كان المستخدم إرسال والحصول على البيانات التي تحتوي على كلمة "confirm" ، والتي يتم تضمينها في جزء اسم النموذج GET في `confirm.html`, ثم أكد المستخدم حذف ويتم إرشاد Django لحذف آخر ويتم إعادة توجيه العميل إلى قائمة المشاركة.
- **Line #5:** إذا كان المستخدم إرسال بيانات GET تحتوي على كلمة "cancel" من النقر على زر الإرسال مع اسم "cancel"، ثم يتم إعادة توجيه العميل إلى قائمة آخر دون حذف آخر
- **Line #6:** وإلا، المستخدم لم يحدد أي شيء، حتى عرض قالب التأكيد.


## Final Thoughts

- يمكن العثور على قائمة الحاجيات المتاحة في [Django Form Field Widgets documentation](https://docs.djangoproject.com/en/3.2/ref/forms/widgets/)
- يجب على المستخدم عدم تذكر المسارات إلى تطبيق ويب
- بدلا من ذلك، أضف ارتباطات إلى طرق العرض للسماح للمستخدمين بتحديد طريقة العرض التي يتم تشغيلها
- The [url template tag](https://docs.djangoproject.com/en/3.2/ref/templates/builtins/#url) مفيد في إنشاء الارتباطات
- إذا لم يتم ربط طريقة عرض، فلن يتمكن المستخدم من الوصول إلى طريقة العرض
- يجب أن تتجاوز المشاهدات الآن 3 نقرات عميقة ، ويفضل أن تكون 2 على الأكثر
  

## Review Questions and Challenges

- ما هي النماذج؟ كيف تكون أشكال جانغو مفيدة؟  
- ما هي أنواع النماذج الرئيسية وكيف تختلف؟
- كيف يختلف نموذج التحديث عن نموذج الإنشاء؟
- لماذا شاشة التأكيد مهمة في عملية الحذف؟
- هل يمكننا استخدام نماذج HTML بدون نماذج Django؟ هل يمكنك إعطاء مثال على المكان الذي يتم فيه ذلك؟